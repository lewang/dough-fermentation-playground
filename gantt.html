<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Gantt Chart Playground</title>
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Chota CSS Framework -->
    <link rel="stylesheet" href="https://unpkg.com/chota@latest">
    
    <!-- Natural language date parsing - Sugar.js for better browser support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sugar/2.0.6/sugar.min.js"></script>
    <script>
        // Create a chrono-like interface using Sugar.js Date parsing
        window.chrono = {
            parseDate: function(text, referenceDate, options) {
                try {
                    // Use Sugar.js Date.create for natural language parsing
                    const date = Sugar.Date.create(text, { future: options && options.forwardDate });
                    return isNaN(date.getTime()) ? null : date;
                } catch (e) {
                    // Fallback to native Date parsing
                    try {
                        const fallbackDate = new Date(text);
                        return isNaN(fallbackDate.getTime()) ? null : fallbackDate;
                    } catch (e2) {
                        return null;
                    }
                }
            },
            parse: function(text, referenceDate, options) {
                // Simple implementation - just return basic info if parsing succeeds
                const date = this.parseDate(text, referenceDate, options);
                if (date) {
                    return [{
                        text: text,
                        index: 0,
                        start: {
                            knownValues: {
                                year: date.getFullYear(),
                                month: date.getMonth() + 1,
                                day: date.getDate(),
                                hour: date.getHours(),
                                minute: date.getMinutes()
                            }
                        }
                    }];
                }
                return [];
            }
        };
    </script>
    
    <style>
        :root {
            --bg-color: #f8f9fa;
            --bg-secondary-color: #e9ecef;
            --surface-color: #ffffff;
            --surface-secondary: #f8f9fa;
            --text-primary: #212529;
            --text-secondary: #495057;
            --border-color: #dee2e6;
            --shadow-color: rgba(0, 0, 0, 0.15);
        }
        
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #343a40;
                --bg-secondary-color: #495057;
                --surface-color: #212529;
                --surface-secondary: #343a40;
                --text-primary: #f8f9fa;
                --text-secondary: #e9ecef;
                --border-color: #495057;
                --shadow-color: rgba(0, 0, 0, 0.5);
            }
        }

        body {
            background: linear-gradient(135deg, var(--bg-color) 0%, var(--bg-secondary-color) 100%);
            min-height: 100vh;
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-primary);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .playground {
            background: var(--surface-color);
            border-radius: 15px;
            padding: 2rem;
            box-shadow: 0 10px 30px var(--shadow-color);
            margin-bottom: 2rem;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--surface-secondary);
            border-radius: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        input, select, textarea {
            background: var(--surface-color);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem;
        }

        .button {
            background: #f0f6ff;
            border: 1px solid #d1e2ff;
            color: #4a5568;
            font-weight: 500;
            transition: all 0.2s ease;
            border-radius: 6px;
            padding: 0.75rem 1rem;
            cursor: pointer;
        }

        .button:hover {
            background: #e0efff;
            border-color: #b3d1ff;
            color: #2d3748;
        }

        .button.primary {
            background: #4299e1;
            color: white;
            border-color: #4299e1;
        }

        .button.primary:hover {
            background: #3182ce;
            border-color: #3182ce;
        }

        #gantt-chart {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--surface-color);
            overflow: auto;
        }

        .gantt-bar {
            cursor: pointer;
        }

        .gantt-bar:hover {
            opacity: 0.8;
        }

        .axis {
            color: var(--text-primary);
        }

        .axis text {
            fill: var(--text-primary);
        }

        .axis path,
        .axis line {
            stroke: var(--border-color);
        }

        .grid line {
            stroke: var(--border-color);
            stroke-dasharray: 3,3;
            opacity: 0.5;
        }

        .task-text {
            font-size: 12px;
            fill: white;
            font-weight: 500;
        }

        .data-editor {
            margin-top: 1rem;
        }

        .data-editor textarea {
            width: 100%;
            height: 200px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9rem;
        }

        .presets {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .preset-btn {
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
        }

        @media (prefers-color-scheme: dark) {
            .task-text {
                fill: #f8f9fa;
            }
        }

        /* Live Task Editor Styles */
        .task-editor {
            background: var(--surface-secondary);
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .task-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 400px;
            overflow-y: auto;
        }

        .task-item {
            display: grid;
            grid-template-columns: 20px 1fr 120px 100px 80px;
            gap: 0.5rem;
            align-items: center;
            padding: 0.75rem;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: move;
        }

        .task-item:hover {
            background: var(--surface-secondary);
        }

        .task-item.dragging {
            opacity: 0.5;
        }

        .task-item.overlap-warning {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .drag-handle {
            cursor: grab;
            color: var(--text-tertiary);
            font-size: 14px;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .task-input {
            border: none;
            background: transparent;
            color: var(--text-primary);
            padding: 0.25rem;
            border-radius: 3px;
        }

        .task-input:focus {
            background: var(--surface-secondary);
            outline: 1px solid var(--color-primary);
        }

        .date-input {
            font-size: 0.9rem;
            padding: 0.25rem;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--surface-color);
        }

        .date-input:focus {
            border-color: var(--color-primary);
        }

        .date-input.invalid {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .category-select {
            font-size: 0.9rem;
            padding: 0.25rem;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--surface-color);
        }

        .delete-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .delete-btn:hover {
            background: #ff5252;
        }

        .add-task-btn {
            margin-top: 1rem;
            background: #4caf50;
            color: white;
        }

        .add-task-btn:hover {
            background: #43a047;
        }

        .editor-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .overlap-info {
            font-size: 0.8rem;
            color: #ff6b6b;
            margin-top: 0.25rem;
        }

        @media (max-width: 768px) {
            .task-item {
                grid-template-columns: 1fr;
                gap: 0.25rem;
            }
            
            .task-item > * {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="playground">
            <h1 class="text-center">üéØ D3 Gantt Chart Playground</h1>
            <p class="text-center" style="color: var(--text-secondary);">Interactive playground for creating and customizing D3.js Gantt charts</p>
            
            <!-- Controls -->
            <div class="controls">
                <div class="control-group">
                    <label>Chart Width</label>
                    <input type="range" id="chartWidth" min="600" max="1200" value="900">
                    <span id="widthValue">900px</span>
                </div>
                
                <div class="control-group">
                    <label>Chart Height</label>
                    <input type="range" id="chartHeight" min="300" max="800" value="400">
                    <span id="heightValue">400px</span>
                </div>
                
                <div class="control-group">
                    <label>Bar Height</label>
                    <input type="range" id="barHeight" min="15" max="50" value="25">
                    <span id="barHeightValue">25px</span>
                </div>
                
                <div class="control-group">
                    <label>Bar Padding</label>
                    <input type="range" id="barPadding" min="2" max="20" value="5">
                    <span id="barPaddingValue">5px</span>
                </div>
                
                <div class="control-group">
                    <label>Color Scheme</label>
                    <select id="colorScheme">
                        <option value="category10">Category10</option>
                        <option value="set3">Set3</option>
                        <option value="pastel1">Pastel1</option>
                        <option value="dark2">Dark2</option>
                        <option value="accent">Accent</option>
                        <option value="custom">Custom Blue</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Time Format</label>
                    <select id="timeFormat">
                        <option value="%m/%d">MM/DD</option>
                        <option value="%m/%d/%Y">MM/DD/YYYY</option>
                        <option value="%b %d">Mon DD</option>
                        <option value="%b %d, %Y">Mon DD, YYYY</option>
                        <option value="%Y-%m-%d">YYYY-MM-DD</option>
                        <option value="%a %m/%d">Day MM/DD</option>
                        <option value="%a %b %d">Day Mon DD</option>
                        <option value="%m/%d %H:%M">MM/DD HH:MM</option>
                        <option value="%b %d %H:%M">Mon DD HH:MM</option>
                        <option value="%a %H:%M">Day HH:MM</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Show Grid</label>
                    <input type="checkbox" id="showGrid" checked>
                </div>
                
                <div class="control-group">
                    <label>Show Task Labels</label>
                    <input type="checkbox" id="showLabels" checked>
                </div>
                
                <div class="control-group">
                    <label>Show Y-Axis Labels</label>
                    <input type="checkbox" id="showYAxis" checked>
                </div>
                
                <div class="control-group">
                    <label>Sort Tasks</label>
                    <select id="sortTasks">
                        <option value="none">No Sorting</option>
                        <option value="start">By Start Date</option>
                        <option value="end">By End Date</option>
                        <option value="duration">By Duration</option>
                        <option value="name">By Task Name</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Animation Duration</label>
                    <input type="range" id="animationDuration" min="0" max="2000" value="750">
                    <span id="animationValue">750ms</span>
                </div>
                
                <div class="control-group">
                    <label>Target End Time</label>
                    <input type="text" id="targetEndTime" placeholder="e.g., tomorrow 5am, next Friday 6pm, in 3 hours" 
                           onchange="updateTargetTime(this.value)">
                    <small style="color: var(--text-tertiary);">All tasks work backwards from this time</small>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="text-center" style="margin-bottom: 2rem;">
                <button class="button primary" onclick="updateChart()">Update Chart</button>
                <button class="button" onclick="exportSVG()">Export SVG</button>
                <button class="button" onclick="exportPNG()">Export PNG</button>
                <button class="button" onclick="randomizeData()">Randomize Data</button>
                <button class="button" onclick="shareURL()">üìã Share URL</button>
            </div>
            
            <!-- Natural Language Date Testing -->
            <div class="task-editor" style="margin-bottom: 2rem;">
                <h3>üß™ Natural Language Date Parser Test</h3>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <div style="display: flex; gap: 1rem; align-items: center;">
                        <input type="text" id="testDateInput" placeholder="Type natural language time here..." 
                               style="flex: 1; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 6px;"
                               oninput="testDateParsing(this.value)">
                        <button class="button" onclick="clearTestInput()">Clear</button>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div>
                            <label style="font-weight: 600; color: var(--text-secondary);">Chrono.js Result:</label>
                            <div id="chronoResult" style="padding: 0.5rem; background: var(--surface-secondary); border-radius: 4px; font-family: monospace; min-height: 2rem;">
                                Enter text to see parsed result...
                            </div>
                        </div>
                        <div>
                            <label style="font-weight: 600; color: var(--text-secondary);">JavaScript Date:</label>
                            <div id="jsDateResult" style="padding: 0.5rem; background: var(--surface-secondary); border-radius: 4px; font-family: monospace; min-height: 2rem;">
                                Enter text to see JS Date object...
                            </div>
                        </div>
                    </div>
                    <div>
                        <label style="font-weight: 600; color: var(--text-secondary);">Test Examples:</label>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem;">
                            <button class="button preset-btn" onclick="testExample('tomorrow 5am')">tomorrow 5am</button>
                            <button class="button preset-btn" onclick="testExample('next Friday 6pm')">next Friday 6pm</button>
                            <button class="button preset-btn" onclick="testExample('in 2 hours')">in 2 hours</button>
                            <button class="button preset-btn" onclick="testExample('today 3:30pm')">today 3:30pm</button>
                            <button class="button preset-btn" onclick="testExample('Jan 15 2pm')">Jan 15 2pm</button>
                            <button class="button preset-btn" onclick="testExample('next Monday at 9am')">next Monday 9am</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Chart Container -->
            <div id="gantt-chart"></div>
            
            <!-- Live Task Editor -->
            <div class="task-editor">
                <h3>üìù Live Task Editor</h3>
                <div class="editor-controls">
                    <button class="button add-task-btn" onclick="addNewTask()">+ Add Task</button>
                    <button class="button" onclick="setTargetTimeToNow()">‚è∞ Set Target to Now</button>
                </div>
                
                <div class="task-list" id="taskList">
                    <!-- Tasks will be rendered here -->
                </div>
            </div>
            
            <!-- Data Editor -->
            <div class="data-editor">
                <h3>üìù Edit Task Data</h3>
                <div class="presets">
                    <button class="button preset-btn" onclick="loadPreset('baking')">üçû Bread Baking</button>
                    <button class="button preset-btn" onclick="loadPreset('cooking')">üçñ Grilling</button>
                    <button class="button preset-btn" onclick="loadPreset('coffee')">‚òï Pour Over Coffee</button>
                    <button class="button preset-btn" onclick="loadPreset('workout')">üí™ Workout Routine</button>
                </div>
                <textarea id="taskData" placeholder="Edit JSON task data here..."></textarea>
                <button class="button" onclick="updateFromJSON()" style="margin-top: 1rem;">Update from JSON</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let chartData = [];
        let chart, svg, xScale, yScale, colorScale;
        let draggedTask = null;
        let taskIdCounter = 1;
        let targetEndTime = new Date(); // When the final task should complete
        
        // Default task data (working backwards from bake time)
        const defaultTasks = [
            {
                id: 1,
                task: "Mix Ingredients",
                duration: "15 minutes",
                category: "Prep"
            },
            {
                id: 2,
                task: "First Rise",
                duration: "2 hours",
                category: "Rising"
            },
            {
                id: 3,
                task: "Shape Dough",
                duration: "10 minutes",
                category: "Prep"
            },
            {
                id: 4,
                task: "Second Rise",
                duration: "1.5 hours",
                category: "Rising"
            },
            {
                id: 5,
                task: "Preheat Oven",
                duration: "30 minutes",
                category: "Prep"
            },
            {
                id: 6,
                task: "Bake",
                duration: "45 minutes",
                category: "Baking"
            }
        ];
        
        // Presets
        const presets = {
            baking: [
                {id: 1, task: "Mix Ingredients", duration: "15 minutes", category: "Prep"},
                {id: 2, task: "First Rise", duration: "2 hours", category: "Rising"},
                {id: 3, task: "Shape Dough", duration: "10 minutes", category: "Prep"},
                {id: 4, task: "Second Rise", duration: "1.5 hours", category: "Rising"},
                {id: 5, task: "Preheat Oven", duration: "30 minutes", category: "Prep"},
                {id: 6, task: "Bake", duration: "45 minutes", category: "Baking"}
            ],
            cooking: [
                {id: 1, task: "Prep Ingredients", duration: "20 minutes", category: "Prep"},
                {id: 2, task: "Marinate Meat", duration: "2 hours", category: "Marinating"},
                {id: 3, task: "Heat Grill", duration: "15 minutes", category: "Setup"},
                {id: 4, task: "Grill Main Course", duration: "25 minutes", category: "Cooking"},
                {id: 5, task: "Rest Meat", duration: "10 minutes", category: "Resting"},
                {id: 6, task: "Plate & Serve", duration: "5 minutes", category: "Serving"}
            ],
            coffee: [
                {id: 1, task: "Grind Beans", duration: "2 minutes", category: "Prep"},
                {id: 2, task: "Heat Water", duration: "5 minutes", category: "Prep"},
                {id: 3, task: "Bloom Coffee", duration: "30 seconds", category: "Brewing"},
                {id: 4, task: "Pour Over", duration: "3 minutes", category: "Brewing"},
                {id: 5, task: "Serve", duration: "1 minute", category: "Serving"}
            ],
            workout: [
                {id: 1, task: "Warm Up", duration: "10 minutes", category: "Prep"},
                {id: 2, task: "Strength Training", duration: "45 minutes", category: "Exercise"},
                {id: 3, task: "Cardio", duration: "20 minutes", category: "Exercise"},
                {id: 4, task: "Cool Down", duration: "10 minutes", category: "Recovery"},
                {id: 5, task: "Stretch", duration: "15 minutes", category: "Recovery"}
            ]
        };
        
        // Duration and Time Calculation Functions
        function parseDuration(durationStr) {
            // Parse natural language duration into milliseconds
            const str = durationStr.toLowerCase().trim();
            
            // Common patterns
            const patterns = [
                { regex: /(\d+(?:\.\d+)?)\s*(?:hours?|hrs?|h)\s*(\d+)?\s*(?:minutes?|mins?|m)?/i, 
                  calc: (match) => (parseFloat(match[1]) * 60 + (match[2] ? parseInt(match[2]) : 0)) * 60 * 1000 },
                { regex: /(\d+(?:\.\d+)?)\s*(?:hours?|hrs?|h)/i, 
                  calc: (match) => parseFloat(match[1]) * 60 * 60 * 1000 },
                { regex: /(\d+(?:\.\d+)?)\s*(?:minutes?|mins?|m)/i, 
                  calc: (match) => parseFloat(match[1]) * 60 * 1000 },
                { regex: /(\d+(?:\.\d+)?)\s*(?:seconds?|secs?|s)/i, 
                  calc: (match) => parseFloat(match[1]) * 1000 },
                { regex: /(\d+(?:\.\d+)?)\s*(?:days?|d)/i, 
                  calc: (match) => parseFloat(match[1]) * 24 * 60 * 60 * 1000 }
            ];
            
            for (const pattern of patterns) {
                const match = str.match(pattern.regex);
                if (match) {
                    return pattern.calc(match);
                }
            }
            
            // Fallback: try to parse as number of minutes
            const num = parseFloat(str);
            if (!isNaN(num)) {
                return num * 60 * 1000; // assume minutes
            }
            
            return 30 * 60 * 1000; // default 30 minutes
        }
        
        function formatDuration(ms) {
            const minutes = Math.floor(ms / (60 * 1000));
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            
            if (hours > 0) {
                return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
            }
            return `${minutes}m`;
        }
        
        function calculateTaskTimes() {
            // Calculate start and end times for all tasks working backwards from targetEndTime
            let currentEndTime = new Date(targetEndTime);
            
            // Work backwards through tasks (reverse order)
            const tasksWithTimes = [];
            
            for (let i = chartData.length - 1; i >= 0; i--) {
                const task = chartData[i];
                const durationMs = parseDuration(task.duration);
                const startTime = new Date(currentEndTime.getTime() - durationMs);
                
                tasksWithTimes.unshift({
                    ...task,
                    startTime: startTime,
                    endTime: new Date(currentEndTime),
                    durationMs: durationMs
                });
                
                // Move backwards for next task
                currentEndTime = new Date(startTime);
            }
            
            return tasksWithTimes;
        }
        
        function updateTargetTime(timeStr) {
            const input = document.getElementById('targetEndTime');
            input.classList.remove('invalid');
            
            try {
                let parsedTime;
                
                // Handle empty input
                if (!timeStr || timeStr.trim() === '') {
                    throw new Error('Empty time');
                }
                
                // Try natural language parsing first
                const chronoResult = chrono.parseDate(timeStr, new Date(), { forwardDate: true });
                if (chronoResult && !isNaN(chronoResult.getTime())) {
                    parsedTime = chronoResult;
                    console.log('Chrono parsed:', timeStr, '->', parsedTime.toLocaleString());
                } else {
                    // Fallback to standard date parsing
                    parsedTime = new Date(timeStr);
                    if (isNaN(parsedTime.getTime())) {
                        throw new Error('Invalid time');
                    }
                }
                
                targetEndTime = parsedTime;
                
                // Update the input to show the parsed result
                input.value = parsedTime.toLocaleString();
                
                updateChart();
                updateURL();
                
            } catch (error) {
                input.classList.add('invalid');
                console.warn('Invalid time format:', timeStr, error);
            }
        }
        
        function setTargetTimeToNow() {
            targetEndTime = new Date();
            document.getElementById('targetEndTime').value = targetEndTime.toLocaleString();
            updateChart();
            updateURL();
        }
        
        // Date parsing test functions
        function testDateParsing(input) {
            const chronoDiv = document.getElementById('chronoResult');
            const jsDateDiv = document.getElementById('jsDateResult');
            
            if (!input || input.trim() === '') {
                chronoDiv.textContent = 'Enter text to see parsed result...';
                jsDateDiv.textContent = 'Enter text to see JS Date object...';
                return;
            }
            
            try {
                // Test Chrono.js parsing
                const chronoResult = chrono.parseDate(input, new Date(), { forwardDate: true });
                
                if (chronoResult && !isNaN(chronoResult.getTime())) {
                    chronoDiv.innerHTML = `
                        <div style="color: #28a745;">‚úÖ SUCCESS</div>
                        <div>Parsed: ${chronoResult.toLocaleString()}</div>
                        <div>ISO: ${chronoResult.toISOString()}</div>
                        <div>Unix: ${chronoResult.getTime()}</div>
                    `;
                } else {
                    chronoDiv.innerHTML = `
                        <div style="color: #dc3545;">‚ùå FAILED</div>
                        <div>Chrono.js could not parse this input</div>
                    `;
                }
                
                // Test JavaScript Date parsing
                const jsDate = new Date(input);
                if (!isNaN(jsDate.getTime())) {
                    jsDateDiv.innerHTML = `
                        <div style="color: #28a745;">‚úÖ SUCCESS</div>
                        <div>Parsed: ${jsDate.toLocaleString()}</div>
                        <div>ISO: ${jsDate.toISOString()}</div>
                        <div>Unix: ${jsDate.getTime()}</div>
                    `;
                } else {
                    jsDateDiv.innerHTML = `
                        <div style="color: #dc3545;">‚ùå FAILED</div>
                        <div>JavaScript Date() could not parse this input</div>
                    `;
                }
                
                // Show detailed Chrono parsing info if available
                if (chronoResult) {
                    const chronoDetails = chrono.parse(input, new Date(), { forwardDate: true });
                    if (chronoDetails && chronoDetails.length > 0) {
                        const detail = chronoDetails[0];
                        chronoDiv.innerHTML += `
                            <div style="margin-top: 0.5rem; font-size: 0.85em; opacity: 0.8;">
                                <div>Text: "${detail.text}"</div>
                                <div>Index: ${detail.index}</div>
                                ${detail.start ? `<div>Components: ${JSON.stringify(detail.start.knownValues, null, 2)}</div>` : ''}
                            </div>
                        `;
                    }
                }
                
            } catch (error) {
                chronoDiv.innerHTML = `
                    <div style="color: #dc3545;">‚ùå ERROR</div>
                    <div>${error.message}</div>
                `;
                jsDateDiv.innerHTML = `
                    <div style="color: #dc3545;">‚ùå ERROR</div>
                    <div>${error.message}</div>
                `;
            }
        }
        
        function testExample(example) {
            document.getElementById('testDateInput').value = example;
            testDateParsing(example);
        }
        
        function clearTestInput() {
            document.getElementById('testDateInput').value = '';
            testDateParsing('');
        }
        
        // Live Task Editor Functions
        function renderTaskList() {
            const taskList = document.getElementById('taskList');
            taskList.innerHTML = '';
            
            chartData.forEach((task, index) => {
                const taskItem = document.createElement('div');
                taskItem.className = 'task-item';
                taskItem.draggable = true;
                taskItem.dataset.index = index;
                
                taskItem.innerHTML = `
                    <div class="drag-handle">‚ãÆ‚ãÆ</div>
                    <input type="text" class="task-input" value="${task.task}" 
                           onchange="updateTaskField(${index}, 'task', this.value)">
                    <input type="text" class="date-input" value="${task.duration}" 
                           placeholder="e.g., 30 minutes, 2 hours, 1.5h"
                           onchange="updateTaskField(${index}, 'duration', this.value)">
                    <select class="category-select" onchange="updateTaskField(${index}, 'category', this.value)">
                        ${getCategories().map(cat => 
                            `<option value="${cat}" ${task.category === cat ? 'selected' : ''}>${cat}</option>`
                        ).join('')}
                    </select>
                    <button class="delete-btn" onclick="deleteTask(${index})">Delete</button>
                `;
                
                // Add drag and drop event listeners
                taskItem.addEventListener('dragstart', handleDragStart);
                taskItem.addEventListener('dragover', handleDragOver);
                taskItem.addEventListener('drop', handleDrop);
                taskItem.addEventListener('dragend', handleDragEnd);
                
                taskList.appendChild(taskItem);
            });
        }
        
        
        function getCategories() {
            const categories = [...new Set(chartData.map(task => task.category))];
            const commonCategories = ['Prep', 'Rising', 'Baking', 'Cooking', 'Brewing', 'Exercise', 'Recovery'];
            return [...new Set([...categories, ...commonCategories])];
        }
        
        function updateTaskField(index, field, value) {
            chartData[index][field] = value;
            renderTaskList();
            updateChart();
            updateTaskDataEditor();
            updateURL();
        }
        
        function addNewTask() {
            const newTask = {
                id: ++taskIdCounter,
                task: "New Task",
                duration: "30 minutes",
                category: "Prep"
            };
            
            chartData.push(newTask);
            renderTaskList();
            updateChart();
            updateTaskDataEditor();
            updateURL();
        }
        
        function deleteTask(index) {
            chartData.splice(index, 1);
            renderTaskList();
            updateChart();
            updateTaskDataEditor();
            updateURL();
        }
        
        
        // Drag and Drop Functions
        function handleDragStart(e) {
            draggedTask = parseInt(e.target.dataset.index);
            e.target.classList.add('dragging');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
        }
        
        function handleDrop(e) {
            e.preventDefault();
            const dropIndex = parseInt(e.target.closest('.task-item').dataset.index);
            
            if (draggedTask !== null && draggedTask !== dropIndex) {
                // Reorder tasks
                const task = chartData.splice(draggedTask, 1)[0];
                chartData.splice(dropIndex, 0, task);
                
                renderTaskList();
                updateChart();
                updateTaskDataEditor();
                updateURL();
            }
        }
        
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedTask = null;
        }
        
        // Initialize
        function init() {
            // Initialize target time
            targetEndTime = new Date(Date.now() + 4 * 60 * 60 * 1000); // 4 hours from now
            document.getElementById('targetEndTime').value = targetEndTime.toLocaleString();
            
            // Try to load from URL first, otherwise use default tasks
            if (!loadFromURL()) {
                chartData = [...defaultTasks];
            }
            updateTaskDataEditor();
            setupEventListeners();
            renderTaskList();
            updateChart();
        }
        
        // Setup event listeners
        function setupEventListeners() {
            const controls = ['chartWidth', 'chartHeight', 'barHeight', 'barPadding', 'animationDuration'];
            controls.forEach(id => {
                const element = document.getElementById(id);
                const valueSpan = document.getElementById(id.replace('chart', '').replace('bar', '').replace('animation', 'animation').toLowerCase() + 'Value') || 
                                document.getElementById(id.replace('Chart', '') + 'Value') ||
                                document.getElementById(id.replace('bar', 'bar') + 'Value') ||
                                document.getElementById('animationValue');
                
                element.addEventListener('input', (e) => {
                    const suffix = id.includes('Duration') ? 'ms' : 'px';
                    if (valueSpan) valueSpan.textContent = e.target.value + suffix;
                });
            });
        }
        
        // Color schemes
        function getColorScale(scheme, categories) {
            switch(scheme) {
                case 'category10':
                    return d3.scaleOrdinal(d3.schemeCategory10);
                case 'set3':
                    return d3.scaleOrdinal(d3.schemeSet3);
                case 'pastel1':
                    return d3.scaleOrdinal(d3.schemePastel1);
                case 'dark2':
                    return d3.scaleOrdinal(d3.schemeDark2);
                case 'accent':
                    return d3.scaleOrdinal(d3.schemeAccent);
                case 'custom':
                    const blueShades = ['#e3f2fd', '#bbdefb', '#90caf9', '#64b5f6', '#42a5f5', '#2196f3', '#1e88e5', '#1976d2'];
                    return d3.scaleOrdinal(blueShades);
                default:
                    return d3.scaleOrdinal(d3.schemeCategory10);
            }
        }
        
        // Sort tasks
        function sortTasks(tasks, sortBy) {
            if (sortBy === 'none') return tasks;
            
            return [...tasks].sort((a, b) => {
                switch(sortBy) {
                    case 'start':
                        return new Date(a.start) - new Date(b.start);
                    case 'end':
                        return new Date(a.end) - new Date(b.end);
                    case 'duration':
                        const durationA = new Date(a.end) - new Date(a.start);
                        const durationB = new Date(b.end) - new Date(b.start);
                        return durationB - durationA;
                    case 'name':
                        return a.task.localeCompare(b.task);
                    default:
                        return 0;
                }
            });
        }
        
        // Main chart update function
        function updateChart() {
            // Get control values
            const width = parseInt(document.getElementById('chartWidth').value);
            const height = parseInt(document.getElementById('chartHeight').value);
            const barHeight = parseInt(document.getElementById('barHeight').value);
            const barPadding = parseInt(document.getElementById('barPadding').value);
            const colorScheme = document.getElementById('colorScheme').value;
            const timeFormat = document.getElementById('timeFormat').value;
            const showGrid = document.getElementById('showGrid').checked;
            const showLabels = document.getElementById('showLabels').checked;
            const showYAxis = document.getElementById('showYAxis').checked;
            const sortBy = document.getElementById('sortTasks').value;
            const animationDuration = parseInt(document.getElementById('animationDuration').value);
            
            // Sort tasks
            const sortedTasks = sortTasks(chartData, sortBy);
            
            // Clear previous chart
            d3.select('#gantt-chart').selectAll('*').remove();
            
            // Margins
            const margin = {
                top: 40, 
                right: 40, 
                bottom: 80, 
                left: showYAxis ? 150 : 20
            };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            // Create SVG
            svg = d3.select('#gantt-chart')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Calculate task times and get extent
            const tasksWithTimes = calculateTaskTimes();
            const dateExtent = d3.extent(tasksWithTimes.flatMap(d => [d.startTime, d.endTime]));
            
            // Create scales
            xScale = d3.scaleTime()
                .domain(dateExtent)
                .range([0, innerWidth]);
            
            yScale = d3.scaleBand()
                .domain(tasksWithTimes.map(d => d.task))
                .range([0, innerHeight])
                .padding(barPadding / 100);
            
            // Color scale
            const categories = [...new Set(tasksWithTimes.map(d => d.category))];
            colorScale = getColorScale(colorScheme, categories);
            
            // Create important dates from task data (start times only)
            const uniqueDates = tasksWithTimes.map(d => d.startTime)
                .concat([tasksWithTimes[tasksWithTimes.length - 1].endTime]) // Add final end time
                .sort((a, b) => a - b);
            
            // Add grid
            if (showGrid) {
                const gridAxis = d3.axisBottom(xScale)
                    .tickValues(uniqueDates)
                    .tickSize(-innerHeight)
                    .tickFormat('');
                
                g.append('g')
                    .attr('class', 'grid')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(gridAxis);
            }
            
            // Create bars
            const bars = g.selectAll('.gantt-bar')
                .data(tasksWithTimes)
                .enter()
                .append('g')
                .attr('class', 'gantt-bar');
            
            // Task bars
            bars.append('rect')
                .attr('x', d => xScale(d.startTime))
                .attr('y', d => yScale(d.task))
                .attr('width', 0)
                .attr('height', yScale.bandwidth())
                .attr('fill', d => colorScale(d.category))
                .attr('rx', 3)
                .transition()
                .duration(animationDuration)
                .attr('width', d => xScale(d.endTime) - xScale(d.startTime));
            
            // Add labels
            if (showLabels) {
                bars.append('text')
                    .attr('class', 'task-text')
                    .attr('x', d => xScale(d.startTime) + 5)
                    .attr('y', d => yScale(d.task) + yScale.bandwidth() / 2)
                    .attr('dy', '0.35em')
                    .text(d => `${d.task} (${formatDuration(d.durationMs)})`)
                    .attr('opacity', 0)
                    .transition()
                    .duration(animationDuration)
                    .attr('opacity', 1);
            }
            
            // Add axes with custom tick values
            const xAxis = d3.axisBottom(xScale)
                .tickValues(uniqueDates)
                .tickFormat(d3.timeFormat(timeFormat));
            
            const yAxis = d3.axisLeft(yScale);
            
            g.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${innerHeight})`)
                .call(xAxis)
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            if (showYAxis) {
                g.append('g')
                    .attr('class', 'axis')
                    .call(yAxis);
            }
            
            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 25)
                .attr('text-anchor', 'middle')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .style('fill', 'var(--text-primary)')
                .text(`Timeline Working Backwards from ${targetEndTime.toLocaleString()}`);
            
            // Add tooltips
            bars.append('title')
                .text(d => `${d.task}\nStart: ${d.startTime.toLocaleString()}\nEnd: ${d.endTime.toLocaleString()}\nDuration: ${formatDuration(d.durationMs)}\nCategory: ${d.category}`);
        }
        
        // Load preset data
        function loadPreset(preset) {
            chartData = [...presets[preset]];
            updateTaskDataEditor();
            renderTaskList();
            updateChart();
            updateURL();
        }
        
        // Update task data editor
        function updateTaskDataEditor() {
            document.getElementById('taskData').value = JSON.stringify(chartData, null, 2);
        }
        
        // Update from JSON
        function updateFromJSON() {
            try {
                const newData = JSON.parse(document.getElementById('taskData').value);
                if (Array.isArray(newData) && newData.length > 0) {
                    chartData = newData;
                    renderTaskList();
                    updateChart();
                    updateURL();
                } else {
                    alert('Invalid JSON data. Must be an array of task objects.');
                }
            } catch (error) {
                alert('Invalid JSON format: ' + error.message);
            }
        }
        
        // Update URL with current data
        function updateURL() {
            const encodedData = btoa(JSON.stringify(chartData));
            const url = new URL(window.location);
            url.searchParams.set('data', encodedData);
            window.history.replaceState({}, '', url);
        }
        
        // Load data from URL
        function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const encodedData = urlParams.get('data');
            
            if (encodedData) {
                try {
                    const decodedData = JSON.parse(atob(encodedData));
                    if (Array.isArray(decodedData) && decodedData.length > 0) {
                        chartData = decodedData;
                        updateTaskDataEditor();
                        renderTaskList();
                        return true;
                    }
                } catch (error) {
                    console.warn('Failed to load data from URL:', error);
                }
            }
            return false;
        }
        
        // Randomize data
        function randomizeData() {
            const tasks = ['Prep Work', 'Primary Process', 'Secondary Process', 'Finishing', 'Quality Check', 'Final Step'];
            const categories = ['Prep', 'Processing', 'Finishing', 'Review'];
            const durations = ['15 minutes', '30 minutes', '1 hour', '2 hours', '45 minutes', '1.5 hours'];
            
            chartData = tasks.map((task, i) => {
                return {
                    id: i + 1,
                    task: task,
                    duration: durations[Math.floor(Math.random() * durations.length)],
                    category: categories[Math.floor(Math.random() * categories.length)]
                };
            });
            
            updateTaskDataEditor();
            renderTaskList();
            updateChart();
            updateURL();
        }
        
        // Export functions
        function exportSVG() {
            const svgElement = document.querySelector('#gantt-chart svg');
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svgElement);
            const blob = new Blob([svgString], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gantt-chart.svg';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function exportPNG() {
            const svgElement = document.querySelector('#gantt-chart svg');
            const svgData = new XMLSerializer().serializeToString(svgElement);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            canvas.width = svgElement.width.baseVal.value;
            canvas.height = svgElement.height.baseVal.value;
            
            img.onload = function() {
                ctx.drawImage(img, 0, 0);
                const a = document.createElement('a');
                a.href = canvas.toDataURL('image/png');
                a.download = 'gantt-chart.png';
                a.click();
            };
            
            img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
        }
        
        // Share URL function
        function shareURL() {
            updateURL();
            const url = window.location.href;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(url).then(() => {
                    alert('URL copied to clipboard! You can now share this link to share your Gantt chart configuration.');
                }).catch(() => {
                    promptForCopy(url);
                });
            } else {
                promptForCopy(url);
            }
        }
        
        function promptForCopy(url) {
            const textArea = document.createElement('textarea');
            textArea.value = url;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            alert('URL has been selected and copied! You can now share this link to share your Gantt chart configuration.');
        }
        
        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>